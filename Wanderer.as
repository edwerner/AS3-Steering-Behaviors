package  {		import flash.geom.ColorTransform;		public class Wanderer extends SteeringVehicle	{ 		// tweak these value to tune behavior		public static var tetherWeight: Number = 20;		public static var wanderWeight: Number = 10;		public static var alignmentWeight: Number = 5;		public static var cohesionWeight: Number = 5;		public static var separationWeight:Number = 5;		public static var obsWeight:Number = 40;				private var _wanderRad:Number = 6;		private var _wanderAng :Number = 0;		private var _wanderDist :Number = 3;		private var _wanderMax :Number = 7;		private var _center : Vector2;		private var _tether: Number = 200;		private var inSightDist:Number = 200;		private var tooCloseDist:Number = 25;		private var vehicles:Number = 30;		private var target:Vector2 = null;				public function Wanderer(aMan:Manager, aX:Number=0, aY:Number=0, aSpeed:Number=0 )		{			super(aMan, aX, aY, aSpeed);			aMan.addChild(this);			_center = new Vector2(500, 400);			//this.setObstacle(_obstacleArray);		}						//this calcSteeringForce combines two forces: tether and wander		//arbitration can be contolled by changing the weights		override protected function calcSteeringForce( ):Vector2		{			var forces:Vector2 = new Vector2( );			forces = forces.add(tether().multiply(tetherWeight));				forces = forces.add(alignment().multiply(alignmentWeight));			forces = forces.add(cohesion().multiply(cohesionWeight));			forces = forces.add(separation().multiply(separationWeight));			forces = forces.add(obstacleAvoid().multiply(obsWeight)); 			//forces = forces.add(wander().multiply(wanderWeight));						return forces;		}		//tether keeps vehicles from wandering too far from center		private function tether() :Vector2		{			if (position.distance(_center) < _tether)				return new Vector2();			else				return seek(_center);		}		//wander is an implementation of the Reynolds wander behavior		/*private function wander() :Vector2		{			_wanderAng += (Math.random()*_wanderMax *2 - _wanderMax);			var redDot :Vector2 = position.add(fwd.multiply(_wanderDist));			var offset :Vector2 = fwd.multiply(_wanderRad);			offset.rotate(_wanderAng);			redDot = redDot.add(offset);			return seek(redDot);		}*/		static public function forwardSum()		{			var sum:Vector2 = new Vector2();			for(var i:int = 0;i<Manager._turtleArray.length;i++)			{				 sum = sum.add(Manager._turtleArray[i].fwd);			}			return sum;		}		public function alignment():Vector2		{			//var sum:Vector2 = new Vector2();			var sum:Vector2 = Manager.flockForward;			sum.normalize();			sum = sum.multiply(_maxSpeed);			sum = sum.subtract(_fwd.multiply(_speed));			return sum;		}		public function separation():Vector2		{			var sum:Vector2 = new Vector2();			var minDistance:Number = Number.MAX_VALUE;			var closeTurtle:VectorTurtle;						for(var i:int = 0;i<Manager._turtleArray.length;i++)			{				if(Manager._turtleArray[i] != this)				{					if(position.distance(Manager._turtleArray[i].position) < minDistance)					{						minDistance = position.distance(Manager._turtleArray[i].position);						closeTurtle = Manager._turtleArray[i];					}				}			}			if(minDistance < tooCloseDist) 			{				return flee(closeTurtle.position).multiply(_maxSpeed);			}			return new Vector2();		}				public function obstacleAvoid():Vector2		{			//trace(_manager._obstacleArray.length);			var steeringForce:Vector2 = new Vector2();			var minDist:Number = Number.MAX_VALUE;			var index:Number;			for (var i:int = 0; i <_manager._obstacleArray.length; i++) 			{				if(position.subtract(_manager._obstacleArray[i].position).magnitude() < minDist)				{					minDist = position.subtract(_manager._obstacleArray[i].position).magnitude();					index = i;				}							}			steeringForce = steeringForce.add(avoid(_manager._obstacleArray[index].position, _manager._obstacleArray[index].rad, 250));			return steeringForce;		}				public function cohesion():Vector2		{			var sum:Vector2 = new Vector2;			var centroid:Vector2 = new Vector2();			centroid = Manager.cohesn;			return seek(centroid);		}	}}