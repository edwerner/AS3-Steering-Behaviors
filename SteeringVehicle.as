package  {		public class SteeringVehicle extends VectorTurtle	{		public static var _maxSpeed: Number = 150;		protected static var _maxForce: Number = 250;		protected static var _mass: Number = 1;		var _obstacleArray:Array;			public function SteeringVehicle(aMan:Manager, aX:Number = 0, 								aY:Number = 0, aSpeed:Number = 0) 		{			super(aMan, aX, aY, aSpeed);			_velocity = new Vector2( );		}		override public function update(dt:Number): void		{			var steeringForce:Vector2 = calcSteeringForce( );			steeringForce = clampSteeringForce(steeringForce);			var acceleration:Vector2 = steeringForce.divide(_mass);			_velocity = _velocity.add(acceleration.multiply(dt));			_speed = _velocity.magnitude();			fwd = _velocity;						if (_speed > _maxSpeed)			{				_speed = _maxSpeed ;				_velocity = fwd.multiply(_speed);			}			move( _velocity.multiply(dt));		}				public function set maxSpeed(s:Number)		{_maxSpeed = s;	}		public function set maxForce(f:Number)		{_maxForce = f;	}						private function clampSteeringForce(force: Vector2 ): Vector2		{			var mag:Number = force.magnitude();			if(mag > _maxForce)			{				force = force.divide(mag);				force = force.multiply(_maxForce);			}			return force;		}				protected function calcSteeringForce( ):Vector2		{			var steeringForce:Vector2 = new Vector2();			return steeringForce;		}						protected function seek(targ:Vector2) : Vector2		{			//sf: steering force			var sf : Vector2 = targ.subtract(position);			sf.normalize( );			sf = sf.multiply(_maxSpeed);			sf = sf.subtract(_velocity);			return sf;		}		protected function flee(targ:Vector2) : Vector2		{			return seek(targ).multiply(-1);		}				protected function avoid(obstaclePos:Vector2, obstacleRadius:Number, safeDistance:Number): Vector2 		{						var sf:Vector2 = new Vector2();			var desVel: Vector2 = obstaclePos.subtract(position); //desired velocity			var distance: Number = desVel.magnitude();						if(distance - obstacleRadius > safeDistance)			{				return new Vector2();			}						if(this.fwd.dot(desVel) < 0)			{				return new Vector2();			}			//trace (obstacleRadius);						var rightDotVTOC:Number = right.dot(desVel);						if(rightDotVTOC >= 0)			{				sf = right.multiply(-1);			}			else if(rightDotVTOC < 0)			{				sf = right;			}						sf = sf.multiply(_maxSpeed);			return sf;		}	}}